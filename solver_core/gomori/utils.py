# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v4SaIj50eUCDmB1wawuaAYxotJftfFpp
"""

import numpy as np
from sympy import *
import math

def restrict(restrictions: list,func: str,type_task: str):
    """
    Переписывает ограничения для решения задачи. 
    Parameters
    ----------
    restrictions: list
        Ограничения
    function: str
        Функция 
    type_task: str
        max или min          
    Returns
    -------
    A: np.array
        Массив значений для ограничений
    B: np.array
        Массив ограничений
    C: np.array
        Массив значений функции     
    grades: list
        Вектор оценок   
    """
    grades = []
    C = []
    for i in func.split('*x')[:-1]:
      C.append(int(i.split()[-1]))
    C = np.array(C, dtype=np.float)    

    A = []
    B = []

    if type_task == 'max':
      for i in restrictions:
        function = str(i)

        if function.find('<=') != -1:
            grades.append(1)
            left, right = function.split('<=')
            B.append(int(right))
            a1 = []
            for i in left.split('*x')[:-1]:
              a1.append(int(i.split()[-1]))
            A.append(a1)          

        elif function.find('>=') != -1:
            grades.append(-1)          
            left, right = function.split('>=')
            B.append(int(right))
            a1 = []
            for i in left.split('*x')[:-1]:
              a1.append(int(i.split()[-1]))
            A.append(a1)
      A = np.array(A, dtype=np.float)
      B = np.array([B], dtype=np.float)
    else:
      for i in restrictions:
        function = str(i)

        if function.find('<=') != -1:
            grades.append(-1)
            left, right = function.split('<=')
            B.append(int(right))
            a1 = []
            for i in left.split('*x')[:-1]:
              a1.append(int(i.split()[-1]))
            A.append(a1)          

        elif function.find('>=') != -1:
            grades.append(1)          
            left, right = function.split('>=')
            B.append(int(right))
            a1 = []
            for i in left.split('*x')[:-1]:
              a1.append(int(i.split()[-1]))
            A.append(a1)
      A = np.array(A, dtype=np.float)
      B = np.array([B], dtype=np.float)



    return A,B,C,grades

def continue_solve(mark_in):  # проверка положительных оценок
    mark = np.copy(mark_in)
    mark = mark[1:]
    for i in mark:
        if i > 0:
            return True,
    return False

def get_mark(matrix, function, basis):  # вычисление оценки
    c_basis = []
    for i in basis:
        c_basis.append(function[i - 1])
    mark = np.dot(c_basis, matrix) - (np.append([0], function))
    return mark

def get_basis(matrix):  # получение базиса
    basis = []
    for i in range(len(matrix)):
        basis.append(matrix.shape[1] - len(matrix) + i)
    return basis

def add_additional_variables(matrix, function,grades):  # добавление переменных к матрице и функции
  sing = np.eye(matrix.shape[0])
  for i in range(len(sing)):
    for j in range(len(sing[i])):
      if sing[i][j] != 0:
        sing[i][j] = sing[i][j]*grades[j]
  matrix = np.concatenate((matrix, sing), axis=1)
  function = np.append(function, matrix.shape[0] * [0])
  return matrix, function

def get_index_output(index_input, matrix_in):
    matrix = np.copy(matrix_in)
    p_0 = matrix[:, 0]
    p_i = matrix[:, index_input]

    p_i[p_i == 0] = -1  # exclude division by zero

    teta = p_0 / p_i
    teta = np.where(teta > 0, teta, np.inf)
    index_output = teta.argmin()

    if teta[index_output] == np.inf:
        raise Exception("Not solution")
    else:
        return index_output

def recount(matrix_in, index_input, index_output):  # пересчет матрицы
    matrix = matrix_in.copy()
    k = matrix[index_output][index_input]
    matrix[index_output] /= k

    for i in range(len(matrix)):
        if i != index_output:
            matrix[i] -= matrix[i][index_input] * matrix[index_output]
    return matrix

def recount_function(matrix_in, index_input, index_output, function):  # пересчет функции
    matrix = matrix_in.copy()

    if function[index_input-1]<0:
      function += function[index_input-1] * (matrix[index_output][1:]*(-1))
    if function[index_input-1]>=0:
      function -= function[index_input-1] * matrix[index_output][1:]

    return function

def solve(matrix, function, basis):
    mark = get_mark(matrix, function, basis)

    flag = continue_solve(mark)

    while flag:  # main loop

        index_input = np.argmax(mark)

        index_output = get_index_output(index_input, matrix)

        matrix = recount(matrix, index_input, index_output)


        function = recount_function(matrix, index_input, index_output, function)


        basis[index_output] = index_input


        mark = get_mark(matrix, function, basis)
        flag = continue_solve(mark)

    return matrix, function, basis

def canonization(a, b, c, grades):
    matrix = np.copy(a)
    vector = np.copy(b)
    function = np.copy(c * -1)

    matrix = np.concatenate((vector.T, matrix), axis=1)
    matrix, function = add_additional_variables(matrix, function,grades)
    basis = get_basis(matrix)

    return matrix, function, basis

def get_interval(matrix_in, function_in, basis_in, mark_in):
    matrix = np.copy(matrix_in)
    function = np.copy(function_in)
    basis = np.copy(basis_in)
    mark = np.copy(mark_in)

    result = mark[0] * -1

    for i in range(len(C)):
        interval = []
        function_edit = function
        interval.append(function_edit[i])

        count = 0
        while not continue_solve(mark):
            count += 1
            function_edit[i] += 0.001
            mark = get_mark(matrix, function_edit, basis)
            if count > 10000:
                break

        interval.append(function_edit[i])
        matrix, function_edit, basis = solve(matrix, function_edit, basis)
        mark = get_mark(matrix, function_edit, basis)

def simplex_method(matrix, function, basis, analysis):
    matrix, function, basis = solve(matrix, function, basis)
    mark = get_mark(matrix, function, basis)

    if analysis:
        get_interval(matrix, function, basis, mark)

    p_0 = matrix[:, 0]

    x = np.zeros(len(C))

    for i in range(len(basis)):
        if (basis[i] - 1) < len(C):
            x[basis[i] - 1] = p_0[i]

    return (matrix,function,basis)