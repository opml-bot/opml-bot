# -*- coding: utf-8 -*-
"""interior point.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OvC_OMqoaacuv75uolaCdI3C1fIJNaC0
"""

import numpy as np
from typing import Callable, Optional
from math import isclose
from autograd import grad, hessian

from solver_core.interior_method.handles.prepocessing import get_variables, restrict


class InteriorPoint:
    """
    Метод решения задачи прямой методом внутренней точки.
    Parameters
    ----------
    """

    def __init__(self, function, restrictions, x0, eps, alpha):

        self.function = sympify(function)
        self.restrictions = restrict(restrictions,self.function)
        self.x = np.concatenate(x0, np.zeros(len(get_variables(restrictions[-1])) - len(get_variables(self.function)))),axis = 0)
        self.eps = eps
        self.alpha = alpha
        self.variables = get_variables(self.restrictions[-1])
        self.lam = np.array([0 for i in range(len(self.restrictions))])
        self.z = np.array([0 for i in range(len(self.x))])

        val = dict()
        for i in range(len(self.x)):
          val[self.variables[i]]=self.x[i]

        grad_c = [] # градиент ограничений
        for k in self.variables:
          b = []
          for i in self.restrictions:
            b.append(sympify(i).diff(k))
          grad_c.append(b)
        grad_c = np.array(grad_c)

        grad_f = [] # градиент функции
        for i in self.variables:
          grad_f.append(self.function.diff(i))
        grad_f = np.array(grad_f)

        c = [] # подставленные значения в ограничения
        for k in self.restrictions:
          b = k
          for i,j in val.items():
            b = b.subs({i:j})
          c.append(b)
        c = np.array(c)

        grad_c_v = [] # подставленные значения в градиент ограничений
        for h in grad_c:
          d = []
          for k in h:
            b = k
            for i,j in val.items():
              b = b.subs({i:j})
            d.append(float(b))
          grad_c_v.append(d)
        grad_c_v = np.array(grad_c_v)

        grad_f_v = [] # подставленные значения в градиент функции
        for h in grad_f:
          b = h
          for i,j in val.items():
            b = b.subs({i:j})
          grad_f_v.append(float(b))
        grad_f_v = np.array(grad_f_v)




    def solve(self):


      W = np.matrix(np.zeros((len(self.variables),len(self.variables))))
      for k in range(len(self.restrictions)):
        d = []
        for i in self.variables:
          b = []
          for j in self.variables:
            b1 = sympify(self.restrictions[k]).diff(i).diff(j)
            for u,v in val.items():
              b1 = b1.subs({u:v})
            b.append(float(b1))
          d.append(b)
        W = W + np.matrix(d)*self.lam[k]
      W = W + np.matrix(np.diag(self.z))
      d = []
      for i in self.variables:
        b = []
        for j in self.variables:
          b1 = sympify(self.function).diff(i).diff(j)
          for u,v in val.items():
            b1 = b1.subs({u:v})
          b.append(float(b1))
        d.append(b)
      W = W + np.matrix(d)

      X = np.matrix(np.diag(self.x)) 
      Z = np.matrix(np.diag(self.z))
      sum_x_z = np.dot(np.linalg.pinv(X),Z)

      zero_matrix = np.matrix(np.zeros((len(grad_c_v[0]),len(grad_c_v[0]))))
      e = np.matrix(np.ones(len(self.variables)).reshape(-1,1))
      z_m = np.matrix(z.reshape(-1,1))
      mu = self.eps/len(self.variables)

      d_x = np.zeros(len(W))
      d_x = np.matrix(d_x.reshape(-1,1))

      d_lam = np.zeros(len(grad_c_v.transpose()))
      d_lam = np.matrix(d_lam.reshape(-1,1))

      A = np.vstack([np.hstack([W + sum_x_z,grad_c_v]),np.hstack([grad_c_v.transpose(),zero_matrix])])

      B = np.vstack([np.matrix(grad_f_v.reshape(-1,1) - np.dot(grad_c_v,np.matrix(self.lam.reshape(-1,1))) - np.matrix(z.reshape(-1,1))),np.matrix(c.reshape(-1,1))])

      D = np.dot(np.linalg.pinv(A),B)

      d_x = D[:len(self.variables)] 
      d_lam = D[len(self.variables):]
      d_z = mu*np.dot(np.linalg.pinv(np.diag(self.x)),e) - z_m - np.dot(sum_x_z,d_x)

      flag = True

      c1 = (np.matrix(grad_f_v.reshape(-1,1) - np.dot(grad_c_v,np.matrix(self.lam.reshape(-1,1))) - np.matrix(self.z.reshape(-1,1))))
      cond_1 = 0
      for i in c1:
        cond_1 +=(float(i)**2)
      c2 = c
      cond_2 = 0
      for i in c2:
        cond_2 +=(float(i)**2)
      c3 = (np.dot(np.dot(X,Z),e) - mu*e)
      cond_3 = 0
      for i in c3:
        cond_3 +=(float(i)**2)

      if cond_1 < self.eps and cond_2 < self.eps and cond_3 < self.eps:
        flag = False 


      while flag:
        val = dict()
        for i in range(len(self.x)):
          val[self.variables[i]]=self.x[i]

        c = [] # подставленные значения в ограничения
        for k in self.restrictions:
          b = k
          for i,j in val.items():
            b = b.subs({i:j})
          c.append(b)
        c = np.array(c)

        grad_c_v = [] # подставленные значения в градиент ограничений
        for h in grad_c:
          d = []
          for k in h:
            b = k
            for i,j in val.items():
              b = b.subs({i:j})
            d.append(float(b))
          grad_c_v.append(d)
        grad_c_v = np.array(grad_c_v)

        grad_f_v = [] # подставленные значения в градиент функции
        for h in grad_f:
          b = h
          for i,j in val.items():
            b = b.subs({i:j})
          grad_f_v.append(float(b))
        grad_f_v = np.array(grad_f_v)


        W = np.matrix(np.zeros((len(self.variables),len(self.variables))))
        for k in range(len(self.restrictions)):
          d = []
          for i in self.variables:
            b = []
            for j in self.variables:
              b1 = sympify(self.restrictions[k]).diff(i).diff(j)
              for u,v in val.items():
                b1 = b1.subs({u:v})
              b.append(float(b1))
            d.append(b)
          W = W + np.matrix(d)*self.lam[k]
        W = W + np.matrix(np.diag(self.z))
        d = []
        for i in self.variables:
          b = []
          for j in self.variables:
            b1 = sympify(self.function).diff(i).diff(j)
            for u,v in val.items():
              b1 = b1.subs({u:v})
            b.append(float(b1))
          d.append(b)
        W = W + np.matrix(d)

        X = np.matrix(np.diag(self.x)) 
        Z = np.matrix(np.diag(self.z))
        sum_x_z = np.dot(np.linalg.pinv(X),Z)

        zero_matrix = np.matrix(np.zeros((len(grad_c_v[0]),len(grad_c_v[0]))))
        e = np.matrix(np.ones(len(self.variables)).reshape(-1,1))
        z_m = np.matrix(self.z.reshape(-1,1))
        mu = self.eps/len(self.variables)

        A = np.vstack([np.hstack([W + sum_x_z,grad_c_v]),np.hstack([grad_c_v.transpose(),zero_matrix])])

        B = np.vstack([np.matrix(grad_f_v.reshape(-1,1) - np.dot(grad_c_v,np.matrix(self.lam.reshape(-1,1))) - np.matrix(self.z.reshape(-1,1))),np.matrix(c.reshape(-1,1))])

        D = np.dot(np.linalg.pinv(A),B)

        d_x = D[:len(self.variables)] 
        d_lam = D[len(self.variables):]
        d_z = mu*np.dot(np.linalg.pinv(np.diag(self.x)),e) - z_m - np.dot(sum_x_z,d_x)

        x_new = self.x.reshape(-1,1) + self.alpha*d_x
        self.x = np.array([float(i) for i in x_new])
        lam_new = self.lam.reshape(-1,1) + self.alpha*d_lam
        self.lam = np.array([float(i) for i in lam_new])
        z_new = self.z.reshape(-1,1) + self.alpha*d_z
        self.z = np.array([float(i) for i in z_new])

        c1 = (np.matrix(grad_f_v.reshape(-1,1) - np.dot(grad_c_v,np.matrix(self.lam.reshape(-1,1))) - np.matrix(self.z.reshape(-1,1))))
        cond_1 = 0
        for i in c1:
          cond_1 +=(float(i)**2)
        c2 = c
        cond_2 = 0
        for i in c2:
          cond_2 +=(float(i)**2)
        c3 = (np.dot(np.dot(X,Z),e) - mu*e)
        cond_3 = 0
        for i in c3:
          cond_3 +=(float(i)**2)

        if cond_1 < self.eps and cond_2 < self.eps and cond_3 < self.eps:
          flag = False 

      return self.x



if __name__ == "__main__":
    f = '-x1 - x2 + x3 + x4'
    subject_to = ['x1 >= x2**2 - 1', 'x2>=0']

    task = InteriorPoint(f, subject_to, [0,0,0,0],eps = 10**-3,alpha = 10**-3)
    ans = task.solve()
    print(ans )

