# -*- coding: utf-8 -*-
"""interior point.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OvC_OMqoaacuv75uolaCdI3C1fIJNaC0
"""

import numpy as np
from typing import Callable, Optional
from math import isclose
from autograd import grad, hessian
from sympy import log

from solver_core.inner_point.handlers.prepocessing import restrict, get_variables


class InteriorPoint:
    """
    Метод решения задачи прямой методом внутренней точки.
    Parameters
    ----------
    """

    def __init__(self, function, restrictions, x0, eps = 10**-3, mu = 10**-18, iter = 100):

        self.function = sympify(function)
        self.restrictions = restrict(restrictions,self.function)
        self.x = np.array(x0)
        self.eps = eps
        self.mu = mu
        self.variables = get_variables(self.restrictions[-1])
        self.iter = iter

    def solve(self):

        L = self.function
        for i in self.restrictions:
          L -= (self.mu*sympify(log(i)))

        val = dict()
        for i in range(len(self.x)):
          val[self.variables[i]]=self.x[i]

        grad_f = [] # градиент функции Лагранжа
        for i in self.variables:
          grad_f.append(L.diff(i))
        grad_f = np.array(grad_f)

        grad_f_v = [] # подставленные значения в градиент функции Лагранжа
        for h in grad_f:
          b = h
          for i,j in val.items():
            b = b.subs({i:j})
          grad_f_v.append(float(b))
        grad_f_v = np.array(grad_f_v)

        d = []
        for i in self.variables:
          b = []
          for j in self.variables:
            b1 = L.diff(i).diff(j)
            for u,v in val.items():
              b1 = b1.subs({u:v})
            b.append(float(b1))
          d.append(b)
        H = np.matrix(d)

        x_new = self.x.reshape(-1,1) - np.dot(-np.linalg.pinv(H),np.matrix(grad_f_v.reshape(-1,1)))
        self.x = np.array([float(i) for i in x_new])

        flag = True

        val = dict()
        for i in range(len(self.x)):
          val[self.variables[i]]=self.x[i]

        grad_f_v = [] # подставленные значения в градиент функции Лагранжа
        for h in grad_f:
          b = h
          for i,j in val.items():
            b = b.subs({i:j})
          grad_f_v.append(float(b))
        grad_f_v = np.array(grad_f_v)

        for i in grad_f_v:
          if i>self.eps:
            flag = True
          else:
            flag = False
        
        iteration = 1

        while flag == True and iteration < self.iter:

          iteration+=1

          val = dict()
          for i in range(len(self.x)):
            val[self.variables[i]]=self.x[i]

          grad_f = [] # градиент функции Лагранжа
          for i in self.variables:
            grad_f.append(L.diff(i))
          grad_f = np.array(grad_f)

          grad_f_v = [] # подставленные значения в градиент функции Лагранжа
          for h in grad_f:
            b = h
            for i,j in val.items():
              b = b.subs({i:j})
            grad_f_v.append(float(b))
          grad_f_v = np.array(grad_f_v)

          d = []
          for i in self.variables:
            b = []
            for j in self.variables:
              b1 = L.diff(i).diff(j)
              for u,v in val.items():
                b1 = b1.subs({u:v})
              b.append(float(b1))
            d.append(b)
          H = np.matrix(d)

          x_new = self.x.reshape(-1,1) - np.dot(-np.linalg.pinv(H),np.matrix(grad_f_v.reshape(-1,1)))
          self.x = np.array([float(i) for i in x_new])
          flag = True

          val = dict()
          for i in range(len(self.x)):
            val[self.variables[i]]=self.x[i]

          grad_f_v = [] # подставленные значения в градиент функции Лагранжа
          for h in grad_f:
            b = h
            for i,j in val.items():
              b = b.subs({i:j})
            grad_f_v.append(float(b))
          grad_f_v = np.array(grad_f_v)

          for i in grad_f_v:
            if i>self.eps:
              flag = True
            else:
              flag = False



        return self.x



if __name__ == "__main__":
    f = '15*x1 +12*x2'
    subject_to = ['x1 + 2*x2 >= 3', '2*x1 -4*x2 <= 5','3*x1+ x2 >= 4']

    task = InteriorPoint(f, subject_to, [0,0],eps = 10**-3)
    ans = task.solve()
    print(ans )